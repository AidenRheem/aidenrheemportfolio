import type { Token } from 'marked';
/**
 * Analyzes a string to determine if it contains an HTML tag and its characteristics.
 *
 * @param {string} raw - Raw string potentially containing an HTML tag
 * @returns {Object|null} Returns null if no tag found, otherwise returns:
 *    {
 *      tag: string      - The name of the HTML tag
 *      isOpening: bool  - True if opening tag, false if closing
 *    }
 *
 * @example
 * isHtmlOpenTag('<div class="test">') // Returns { tag: 'div', isOpening: true }
 * isHtmlOpenTag('</span>') // Returns { tag: 'span', isOpening: false }
 * isHtmlOpenTag('plain text') // Returns null
 */
export declare const isHtmlOpenTag: (raw: string) => {
    tag: string;
    isOpening: boolean;
} | null;
/**
 * Parses HTML attributes from a tag string into a structured object.
 * Handles both single and double quoted attributes.
 *
 * @param {string} raw - Raw HTML tag string containing attributes
 * @returns {Record<string, string>} Map of attribute names to their values
 *
 * @example
 * extractAttributes('<div class="foo" id="bar">')
 * // Returns { class: 'foo', id: 'bar' }
 *
 * @internal
 */
export declare const extractAttributes: (raw: string) => Record<string, string>;
/**
 * Converts an HTML string into a sequence of tokens using htmlparser2.
 * Handles complex nested structures while maintaining proper order and relationships.
 *
 * Key features:
 * - Preserves original HTML structure without automatic tag closing
 * - Handles self-closing tags with proper XML syntax (e.g., <br/> instead of <br>)
 * - Gracefully handles malformed HTML by preserving the original structure
 * - Maintains attribute information in opening tags
 * - Processes text content between tags
 *
 * @param {string} html - HTML string to be parsed
 * @returns {Token[]} Array of tokens representing the HTML structure
 *
 * @example
 * // Well-formed HTML
 * parseHtmlBlock('<div>Hello <span>world</span></div>')
 * // Returns [
 * //   { type: 'html', raw: '<div>', ... },
 * //   { type: 'text', raw: 'Hello ', ... },
 * //   { type: 'html', raw: '<span>', ... },
 * //   { type: 'text', raw: 'world', ... },
 * //   { type: 'html', raw: '</span>', ... },
 * //   { type: 'html', raw: '</div>', ... }
 * // ]
 *
 * // Self-closing tags
 * parseHtmlBlock('<div>Before<br/>After</div>')
 * // Returns [
 * //   { type: 'html', raw: '<div>', ... },
 * //   { type: 'text', raw: 'Before', ... },
 * //   { type: 'html', raw: '<br/>', ... },
 * //   { type: 'text', raw: 'After', ... },
 * //   { type: 'html', raw: '</div>', ... }
 * // ]
 *
 * // Malformed HTML
 * parseHtmlBlock('<div>Unclosed')
 * // Returns [
 * //   { type: 'html', raw: '<div>', ... },
 * //   { type: 'text', raw: 'Unclosed', ... }
 * // ]
 *
 * @internal
 */
export declare const parseHtmlBlock: (html: string) => Token[];
/**
 * Determines if an HTML string contains multiple distinct tags.
 * Used as a preprocessing step to optimize token processing.
 *
 * @param {string} html - HTML string to analyze
 * @returns {boolean} True if multiple tags are present or if it's a single pair of matching tags
 *
 * @internal
 */
export declare const containsMultipleTags: (html: string) => boolean;
/**
 * Primary entry point for HTML token processing. Transforms flat token arrays
 * into properly nested structures while preserving HTML semantics.
 *
 * Key features:
 * - Breaks down complex HTML structures into atomic tokens
 * - Maintains attribute information
 * - Preserves proper nesting relationships
 * - Handles malformed HTML gracefully
 *
 * @param {Token[]} tokens - Array of tokens to process
 * @returns {Token[]} Processed and properly nested token array
 *
 * @example
 * const tokens = [
 *   { type: 'html', raw: '<div class="wrapper">' },
 *   { type: 'text', raw: 'content' },
 *   { type: 'html', raw: '</div>' }
 * ];
 * shrinkHtmlTokens(tokens);
 * // Returns nested structure with proper token relationships
 *
 * @public
 */
export declare const shrinkHtmlTokens: (tokens: Token[]) => Token[];
/**
 * Core token processing logic that handles the complexities of HTML nesting.
 * Uses a stack-based approach to match opening and closing tags while
 * maintaining proper hierarchical relationships.
 *
 * Implementation details:
 * - Maintains a stack of opening tags
 * - Processes nested tokens recursively
 * - Preserves HTML attributes
 * - Handles malformed HTML gracefully
 *
 * @param {Token[]} tokens - Tokens to be processed
 * @returns {Token[]} Processed tokens with proper nesting structure
 *
 * @internal
 */
export declare const processHtmlTokens: (tokens: Token[]) => Token[];
